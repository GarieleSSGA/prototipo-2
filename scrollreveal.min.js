/*! @license ScrollReveal v4.0.9
   Copyright 2021 Fisssion LLC.
   Licensed under the GNU General Public License 3.0 for
   compatible open source projects and non-commercial use.
   For commercial sites, themes, projects, and applications,
   keep your source code private/proprietary by purchasing
   a commercial license from https://scrollrevealjs.org/
*/
var ScrollReveal = function() {
    "use strict";

    // Configuraciones predeterminadas
    var defaults = {
        delay: 0,
        distance: "0",
        duration: 600,
        easing: "cubic-bezier(0.5, 0, 0, 1)",
        interval: 0,
        opacity: 0,
        origin: "bottom",
        rotate: { x: 0, y: 0, z: 0 },
        scale: 1,
        cleanup: false,
        container: document.documentElement,
        desktop: true,
        mobile: true,
        reset: false,
        useDelay: "always",
        viewFactor: 0,
        viewOffset: { top: 0, right: 0, bottom: 0, left: 0 },
        afterReset: function() {},
        afterReveal: function() {},
        beforeReset: function() {},
        beforeReveal: function() {}
    };

    // Funciones útiles
    var utilities = {
        success: function() {
            document.documentElement.classList.add("sr");
            if (document.body) {
                document.body.style.height = "100%";
            } else {
                document.addEventListener("DOMContentLoaded", function() {
                    document.body.style.height = "100%";
                });
            }
        },
        failure: function() {
            document.documentElement.classList.remove("sr");
            return {
                clean: function() {},
                destroy: function() {},
                reveal: function() {},
                sync: function() {},
                get noop() { return true; }
            };
        }
    };

    // Comprueba si el elemento es un nodo
    function isNode(obj) {
        return (typeof window.Node === "object" ? obj instanceof window.Node : obj && typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string");
    }

    // Filtra elementos válidos
    function filterNodes(arr) {
        if (Array.isArray(arr)) {
            return arr.filter(isNode);
        }
        if (isNode(arr)) {
            return [arr];
        }
        if (typeof arr === "string") {
            try {
                var nodeList = document.querySelectorAll(arr);
                return Array.prototype.slice.call(nodeList);
            } catch (e) {
                return [];
            }
        }
        return [];
    }

    // Verifica si el objeto es un objeto literal
    function isPlainObject(obj) {
        return obj !== null && typeof obj === "object" && obj.constructor === Object;
    }

    // Itera sobre un objeto o array
    function forEach(obj, callback) {
        if (isPlainObject(obj)) {
            Object.keys(obj).forEach(function(key) {
                return callback(obj[key], key, obj);
            });
        } else if (Array.isArray(obj)) {
            obj.forEach(function(item, index) {
                return callback(item, index, obj);
            });
        } else {
            throw new TypeError("Expected either an array or object literal.");
        }
    }

    // Función de registro
    function log(message) {
        if (ScrollReveal.debug && console) {
            var logMessage = "%cScrollReveal: " + message;
            Array.prototype.slice.call(arguments, 1).forEach(function(arg) {
                logMessage += "\n — " + arg;
            });
            console.log(logMessage, "color: #ea654b;");
        }
    }

    // Limpieza de elementos revelados
    function cleanRevealedElements() {
        var _this = this;
        try {
            forEach(filterNodes("[data-sr-id]"), function(elem) {
                var id = parseInt(elem.getAttribute("data-sr-id"));
                if (id !== null) {
                    clearTimeout(_this.store.elements[id].callbackTimer);
                    applyStyles(_this.store.elements[id].node, _this.store.elements[id].styles.inline.generated);
                    elem.removeAttribute("data-sr-id");
                    delete _this.store.elements[id];
                }
            });
        } catch (error) {
            return log.call(this, "Clean failed.", error.message);
        }
        try {
            reset.call(this);
        } catch (error) {
            return log.call(this, "Clean failed.", error.message);
        }
    }

    // Aplica estilos a un elemento
    function applyStyles(element, styles) {
        styles.split(";").forEach(function(style) {
            var pair = style.split(":");
            var property = pair[0].trim();
            var value = pair.slice(1).join(":");
            if (property && value) {
                element.style[property] = value;
            }
        });
    }

    // Inicialización del ScrollReveal
    function init() {
        var _this2 = this;
        try {
            this.store.history.forEach(function(item) {
                reveal.call(_this2, item.target, item.options, true);
            });
            initTimeout && window.clearTimeout(initTimeout);
            initTimeout = window.setTimeout(initScrollReveal.bind(this), 0);
        } catch (error) {
            return log.call(this, "Initialization failed.", error.message);
        }
    }

    // ScrollReveal
    var ScrollReveal = function ScrollReveal(config) {
        if (config === void 0) { config = {}; }
        if (this === void 0 || Object.getPrototypeOf(this) !== ScrollReveal.prototype) {
            return new ScrollReveal(config);
        }
        if (!ScrollReveal.isSupported()) {
            log.call(this, "Instantiation failed.", "This browser is not supported.");
            return utilities.failure();
        }
        try {
            config = v({}, defaults, config);
        } catch (error) {
            return log.call(this, "Invalid configuration.", error.message), utilities.failure();
        }
        try {
            if (!filterNodes(config.container)[0]) {
                throw new Error("Invalid container.");
            }
        } catch (error) {
            return log.call(this, error.message), utilities.failure();
        }
        if ((!config.mobile && isMobile()) || (!config.desktop && !isMobile())) {
            log.call(this, "This device is disabled.", "desktop: " + config.desktop, "mobile: " + config.mobile);
            return utilities.failure();
        }
        utilities.success();
        this.store = {
            containers: {},
            elements: {},
            history: [],
            sequences: {}
        };
        this.pristine = true;
        this.defaults = config;
        this.version = "4.0.9";
        this.delegate = A;
        this.destroy = P;
        this.reveal = L;
        this.clean = M;
        this.sync = init;
        return this;
    };

    // Exponer ScrollReveal
    return ScrollReveal;
}();
